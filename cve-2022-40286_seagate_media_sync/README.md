# CVE-2022-40286 - Seagate Media Sync

## Introduction

PoC written in Rust for [CVE-2022-40286](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-40286), which was a local privilege escalation vulnerability in Seagate Media Sync version 2.01.0414 on Windows.

All credit goes to [@x86matthew](https://x.com/x86matthew) for the original discovery and initial [PoC](https://www.x86matthew.com/view_post?id=windows_seagate_lpe).

After having read the amazing [write-up](https://www.x86matthew.com/view_post?id=windows_seagate_lpe) by [@x86matthew](https://x.com/x86matthew), I wanted to recreate the PoC as way to learn Rust and understand more about named pipes in Windows.

Below are some reverse engineering notes using WinDbg and Ghidra.

## List Processes
List processes and filter by ProcessName:
```powershell
PS C:\> Get-Process -Name *media*

Handles  NPM(K)    PM(K)      WS(K)     CPU(s)     Id  SI ProcessName
-------  ------    -----      -----     ------     --  -- -----------
    316      24     5352      13224              4120   0 MediaAggreService
    238      18     4848      21968       0.11   7956   1 stxmediamanager
    249      15     2984      12868       0.02   7940   1 stxmediamenumgr
```

## Named Pipes
List named pipes and grep for keyword:
```powershell
PS C:\> (Get-ChildItem \\.\pipe\).FullName | Select-String media

\\.\pipe\MEDIA_AGGRE_PIPE.PIP
\\.\pipe\media_sync_sys_tray_status.PIP
```

## Name Pipe Server - MediaAggreService.exe

### Search Strings
Search for strings in decompiler:
```
u_\\.\PIPE\MEDIA_AGGRE_PIPE.PIP_00023b4c        XREF[1]:     FUN_00014170:00014219 (*)   
unicode    u"\\\\.\\PIPE\\MEDIA_AGGRE_PIPE.PIP"
00023b4c  5c  00  5c  00  2e  00  5c  00  50  00  49  00  50  00  45  00  5c  00  4d  00
          45  00  44  00  49  00  41  00  5f  00  41  00  47  00  47  00  52  00  45  00 
          5f  00  50  00  49  00  50  00  45  00  2e  00  50  00  49  00  50  00  00  00
```

### Lookup Cross-References
```
00014219		PUSH u_\\.\PIPE\MEDIA_AGGRE_PIPE.PIP_00023b4c	DATA
```

### Main Event Loop
WinDbg:
```
u MediaAggreService+000141e7 MediaAggreService+0001427e ; $$ disassesmble start_address end_address (inclusive)
```

Main event loop that creates the named pipe and starts new worker threads:
```
000141e7 0f 8e 91 00 00 00     JLE        LAB_0001427e
000141ed 8b 1d 48 d2 01 00     MOV        EBX, dword ptr [->MSVCR110.DLL::_errno]

LAB_000141f3                   XREF[1]:   00014278 (j)
000141f3 68 d8 f0 01 00        PUSH       u_[THREAD-LaunchAppThreadProc]_Dup_0001f0d8
000141f8 e8 df 46 00 00        CALL       MFC110U.DLL::operator_new
000141fd 83 c4 04              ADD        ESP, 0x4
00014200 89 45 08              MOV        dword ptr [EBP + param_1], EAX
00014203 c7 45 fc 00 00 00 00  MOV        dword ptr [EBP + local_8], 0x0
0001420a 85 c0                 TEST       EAX, EAX
0001420c 74 19                 JZ         LAB_00014227
0001420e ff 75 0c              PUSH       dword ptr [EBP + param_2]
00014211 8b c8                 MOV        ECX, EAX
00014213 ff 35 10 42 03 00     PUSH       dword ptr [DAT_00034210]
00014219 68 4c 3b 02 00        PUSH       u_\\.\PIPE\MEDIA_AGGRE_PIPE.PIP_00023b4c
0001421e e8 7d 00 00 00        CALL       FUN_000142a0
00014223 8b c8                 MOV        ECX, EAX
00014225 eb 02                 JMP        LAB_00014229

LAB_00014227                   XREF[1]:   0001420c (j)
00014227 33 c9                 XOR        ECX, ECX

LAB_00014229                   XREF[1]:   00014225 (j)
00014229 8b 47 04              MOV        EAX, dword ptr [EDI + 0x4]
0001422c c7 45 fc ff ff ff ff  MOV        dword ptr [EBP + local_8], 0xffffffff
00014233 89 0c b0              MOV        dword ptr [EAX + ESI * 0x4], ECX
00014236 8d 45 f0              LEA        EAX =>local_14, [EBP + -0x10]
00014239 50                    PUSH       EAX
0001423a 8b 47 04              MOV        EAX, dword ptr [EDI + 0x4]
0001423d 6a 00                 PUSH       0x0
0001423f ff 34 b0              PUSH       dword ptr [EAX + ESI * 0x4]
00014242 68 30 47 01 00        PUSH       FUN_00014730
00014247 6a 00                 PUSH       0x0
00014249 6a 00                 PUSH       0x0
0001424b ff 15 4c d2 01 00     CALL       dword ptr [->MSVCR110.DLL::_beginthreadex]
00014251 8b 0f                 MOV        ECX, dword ptr [EDI]
00014253 83 c4 18              ADD        ESP, 0x18
00014256 89 04 b1              MOV        dword ptr [ECX + ESI * 0x4], EAX
00014259 8b 07                 MOV        EAX, dword ptr [EDI]
0001425b 83 3c b0 00           CMP        dword ptr [EAX + ESI * 0x4], 0x0
0001425f 75 13                 JNZ        LAB_00014274
00014261 53                    PUSH       EBX
00014262 68 88 3b 02 00        PUSH       u_Failure:__beginthreadex()_--_err_00023b88
00014267 68 f0 84 04 00        PUSH       DAT_000484f0
0001426c e8 3f 6a ff ff        CALL       FUN_0000acb0
00014271 83 c4 0c              ADD        ESP, 0xc

LAB_00014274                   XREF[1]:   0001425f (j)
00014274 46                    INC        ESI
00014275 3b 77 08              CMP        ESI, dword ptr [EDI + 0x8]
00014278 0f 8c 75 ff ff ff     JL         LAB_000141f3

LAB_0001427e                   XREF[1]:   000141e7 (j)
0001427e 8b c7                 MOV        EAX, EDI
```

### Worker Thread
Decompilation:
```c
undefined4 FUN_00014730(undefined4 *param_1)
{
  GetCurrentThreadId();
  FUN_0000ad70(0x484f0,L"[THREAD-ServerPipe] Starting thread %u");
  FUN_000143a0(param_1); // <------------------------------------ call function to communicate with named pipe
  if (param_1 != (undefined4 *)0x0) {
    FUN_00014320(param_1);
    operator_delete(param_1);
  }
  GetCurrentThreadId();
  FUN_0000ad70(0x484f0,L"[THREAD-ServerPipe] Ending thread %u");
  return 0;
}
```

### Read Stage 1 - Command Size
WinDbg:
```
u MediaAggreService+000143dc L5 ; $$ disassemble L_ instructions
```

The first stage involves reading a hardcoded 4 bytes from the named pipe.
These 4 bytes represent the size of the command to be read by the server in stage 2.

Preparing args for function call to read 4 bytes from named pipe:
```
000143dc 68 30 75 00 00        PUSH       0x7530
000143e1 6a 04                 PUSH       0x4
000143e3 57                    PUSH       EDI
000143e4 8b ce                 MOV        param_1, ESI
000143e6 e8 b5 84 ff ff        CALL       FUN_0000c8a0
```

### Read Stage 2 - Seagate Command
WinDbg:
```
u MediaAggreService+000143f3 MediaAggreService+000143f5 ; $$ disassesmble start_address end_address (inclusive)
```

`MFC110U.DLL::operator_new()` is similar to malloc.

Allocate a heap buffer based on the command size, then read stage 2 from the named pipe into the buffer:
```
000143f3 ff 37                 PUSH       dword ptr [EDI]=>u_ANDLE_0001f038+148
000143f5 e8 d6 44 00 00        CALL       MFC110U.DLL::operator_new[]
000143fa 83 c4 04              ADD        ESP, 0x4
000143fd 8b ce                 MOV        param_1, ESI
000143ff 68 30 75 00 00        PUSH       0x7530
00014404 ff 37                 PUSH       dword ptr [EDI]=>u_ANDLE_0001f038+148
00014406 89 86 d0 f0 01 00     MOV        dword ptr [ESI + u_DLE_0001f038+152], EAX
0001440c 50                    PUSH       EAX
0001440d e8 8e 84 ff ff        CALL       FUN_0000c8a0
```

### Examine Stage 2 Seagate Command
WinDbg:
```
bp MediaAggreService+0001469c ; $$ breakpoint before calling PIPEUI function
db poi(@esp + 4) L3010        ; $$ dereference pointer on stack that references seagate command heap buffer
```

WinDbg:
```
bp MediaAggreService+0x12840 ; $$ breakpoint in PIPEUI command function
db poi(@esp + 8) L3010       ; $$ dereference pointer on stack that references seagate command heap buffer
```

Stage 2 payload was sent using valid signature, major command, minor command.
Remainder of the payload was just easily identifiable data.

Heap buffer containing the seagate command:
```
02844f38  5c 4b 10 00 00 04 00 00-41 00 41 00 41 00 41 00  \K......A.A.A.A.
02844f48  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.
02844f58  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.
02844f68  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.

[REDACTED]

02845f18  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.
02845f28  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.
02845f38  41 00 41 00 41 00 00 00-42 00 42 00 42 00 42 00  A.A.A...B.B.B.B.
02845f48  42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00  B.B.B.B.B.B.B.B.
02845f58  42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00  B.B.B.B.B.B.B.B.

[REDACTED]

02846f18  42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00  B.B.B.B.B.B.B.B.
02846f28  42 00 42 00 42 00 42 00-42 00 42 00 42 00 42 00  B.B.B.B.B.B.B.B.
02846f38  42 00 42 00 42 00 00 00-43 00 43 00 43 00 43 00  B.B.B...C.C.C.C.
02846f48  43 00 43 00 43 00 43 00-43 00 43 00 43 00 43 00  C.C.C.C.C.C.C.C.
02846f58  43 00 43 00 43 00 43 00-43 00 43 00 43 00 43 00  C.C.C.C.C.C.C.C.

[REDACTED]

02847f08  43 00 43 00 43 00 43 00-43 00 43 00 43 00 43 00  C.C.C.C.C.C.C.C.
02847f18  43 00 43 00 43 00 43 00-43 00 43 00 43 00 43 00  C.C.C.C.C.C.C.C.
02847f28  43 00 43 00 43 00 43 00-43 00 43 00 43 00 43 00  C.C.C.C.C.C.C.C.
02847f38  43 00 43 00 43 00 00 00-fe 0f 00 00 00 00 00 00  C.C.C...........
```

### Parse Seagate Command
WinDbg:
```
u MediaAggreService+0001441e L4 ; $$ disassemble L_ instructions
```

Call function to interpret the command received in stage 2:
```
LAB_0001441e  XREF[1]:   00014414 (j)
0001441e 8b ce                 MOV        param_1, ESI
00014420 e8 5b 01 00 00        CALL       FUN_00014580
00014425 85 c0                 TEST       EAX, EAX
00014427 75 08                 JNZ        LAB_00014431
```

### Check Command Size
WinDbg:
```
u MediaAggreService+00014590 L5 ; $$ disassemble L_ instructions
```

Check command size > 8 bytes:
```
00014590 8b 86 cc f0 01 00     MOV        EAX, dword ptr [ESI + u_ANDLE_0001f038+148]
00014596 83 f8 08              CMP        EAX, 0x8
00014599 73 1a                 JNC        LAB_000145b5
0001459b 50                    PUSH       EAX
0001459c 68 90 39 02 00        PUSH       u_[PIPE]_Failure:_Bad_Command_size_00023990
```

### Check Signature
WinDbg:
```
u MediaAggreService+000145bb L6 ; $$ disassemble L_ instructions
```

Check signature == 0x4b5c:
```
000145bb ba 5c 4b 00 00        MOV        EDX, 0x4b5c
000145c0 0f b7 08              MOVZX      param_1, word ptr [EAX]
000145c3 66 3b ca              CMP        param_1, DX
000145c6 74 1a                 JZ         LAB_000145e2
000145c8 51                    PUSH       param_1
000145c9 68 d8 39 02 00        PUSH       u_[PIPE]_Failure:_Bad_Signature_0x_000239d8
```

### Major Command
WinDbg:
```
u MediaAggreService+0001460e ; $$ disassemble instructions
```

Check major command:
- 0x10 -> PIPEUI
- 0x20 -> PIPESYNC

Decompilation:
```c
  if (sVar1 == 0x10) {
    FUN_0000ad70(0x484f0,L"  PIPEUI");
    iVar2 = FUN_00012840([REDACTED]);
  }
  else {
    if (sVar1 != 0x20) {
      FUN_0000acb0((short *)&DAT_000484f0,L"[PIPE] Failure: Unkown Major Command");
      return 0;
    }
    FUN_0000ad70(0x484f0,L"  PIPESYNC START");
    iVar2 = FUN_00012310([REDACTED]);
    FUN_0000ad70(0x484f0,L"  PIPESYNC END");
  }
```

### Minor Command
WinDbg:
```
u MediaAggreService+00012888 ; $$ beginning of switch case
u MediaAggreService+000136d5 ; $$ case 0x400 L"- Set String Registry"
u MediaAggreService+00013399 ; $$ case 0x410 L"- Set DWORD Registry"
```

Case 0x400 L"- Set String Registry" calls external function `STXMEDIADEVIF.DLL::MXOSRVSetRegKey`
Decompilation:
```c
  case 0x400:
    FUN_0000acb0((short *)&DAT_000484f0,L"- Set String Registry");
    FUN_00018d58();
    local_14 = MXOSRVSetRegKey((wchar_t *)((int)this + 0x1a9c0),(wchar_t *)((int)this + 0x1b9c0),
                               (wchar_t *)((int)this + 0x1c9c0),*(int *)((int)this + 0x1d9c0));
```

```
                *************************************************************
                *                 POINTER to EXTERNAL FUNCTION               
                *************************************************************
                int __cdecl MXOSRVSetRegKey(wchar_t * lpSubKey, wchar_t * lpValueName, wchar_t * lpData, int cbData)
int               EAX:4          <RETURN>
wchar_t *         Stack[0x4]:4   lpSubKey
wchar_t *         Stack[0x8]:4   lpValueName
wchar_t *         Stack[0xc]:4   lpData
int               Stack[0x10]:4  cbData
                61  ?MXOSRVSetRegKey@@YAHPA_W00H@Z  <<not bound>>
                PTR_MXOSRVSetRegKey_0001d368                    XREF[1]:     parse_pipe_ui_cmd:0001370e (R)   
0001d368 40  da  02  00              addr       STXMEDIADEVIF.DLL::MXOSRVSetRegKey
```

Case 0x410 L"- Set DWORD Registry" calls external function `STXMEDIADEVIF.DLL::MXOSRVSetDWORDRegKey`
Decompilation:
```c
  if (uVar10 == 0x410) {
    FUN_0000acb0((short *)&DAT_000484f0,L"- Set DWORD Registry");
    FUN_00018d58();
    local_14 = MXOSRVSetDWORDRegKey
                         ((wchar_t *)((int)this + 0x1a9c0),(wchar_t *)((int)this + 0x1b9c0),
                          *(ulong *)((int)this + 0x1d9c4))
    *local_18 = 0;
    goto LAB_00013c67;
  }
```

```
                *************************************************************
                *                 POINTER to EXTERNAL FUNCTION               
                *************************************************************
                int __cdecl MXOSRVSetDWORDRegKey(wchar_t * lpSubKey, wchar_t * lpValueName, ulong lpData)
int               EAX:4          <RETURN>
wchar_t *         Stack[0x4]:4   lpSubKey
wchar_t *         Stack[0x8]:4   lpValueName
ulong             Stack[0xc]:4   lpData
                58  ?MXOSRVSetDWORDRegKey@@YAHPA_W0K@Z  <<not bound>>
                PTR_MXOSRVSetDWORDRegKey_0001d36c               XREF[1]:     parse_pipe_ui_cmd:0001375a (R)   
0001d36c 62  da  02  00              addr       STXMEDIADEVIF.DLL::MXOSRVSetDWORDRegKey
```

## Library - STXMEDIADEVIF.DLL

### Set Registry String
Decompilation:
```c
int __cdecl MXOSRVSetRegKey(wchar_t *param_1,wchar_t *param_2,wchar_t *param_3,int param_4)
{
  LSTATUS LVar1;
  DWORD local_c;
  HKEY local_8;
  
                    /* 0x5590  62  ?MXOSRVSetRegKey@@YAHPA_W00H@Z */
  local_8 = (HKEY)0x0;
  LVar1 = RegCreateKeyExW((HKEY)0x80000002,param_1,0,L"",0,0xf003f,(LPSECURITY_ATTRIBUTES)0x0,
                          &local_8,&local_c);
  if (LVar1 == 0) {
    RegSetValueExW(local_8,param_2,0,1,(BYTE *)param_3,param_4);
    RegCloseKey(local_8);
  }
  return 0;
}
```

### Set Registry DWORD
Decompilation:
```c
int __cdecl MXOSRVSetDWORDRegKey(wchar_t *param_1,wchar_t *param_2,ulong param_3)
{
  LSTATUS LVar1;
  DWORD local_c;
  HKEY local_8;
  
                    /* 0x53c0  59  ?MXOSRVSetDWORDRegKey@@YAHPA_W0K@Z */
  local_8 = (HKEY)0x0;
  LVar1 = RegCreateKeyExW((HKEY)0x80000002,param_1,0,L"",0,0xf003f,(LPSECURITY_ATTRIBUTES)0x0,
                          &local_8,&local_c);
  if (LVar1 == 0) {
    RegSetValueExW(local_8,param_2,0,4,(BYTE *)&param_3,4);
    RegCloseKey(local_8);
  }
  return 0;
}
```

### Hardcoded Key Handles
Both `RegCreateKeyExW` function calls above use hardcoded hkey param value of 0x80000002 == HKEY_LOCAL_MACHINE

Defined in `winreg.h`:
```c
#define HKEY_CLASSES_ROOT                   (( HKEY ) (ULONG_PTR)((LONG)0x80000000) )
#define HKEY_CURRENT_USER                   (( HKEY ) (ULONG_PTR)((LONG)0x80000001) )
#define HKEY_LOCAL_MACHINE                  (( HKEY ) (ULONG_PTR)((LONG)0x80000002) )
#define HKEY_USERS                          (( HKEY ) (ULONG_PTR)((LONG)0x80000003) )
#define HKEY_PERFORMANCE_DATA               (( HKEY ) (ULONG_PTR)((LONG)0x80000004) )
#define HKEY_PERFORMANCE_TEXT               (( HKEY ) (ULONG_PTR)((LONG)0x80000050) )
#define HKEY_PERFORMANCE_NLSTEXT            (( HKEY ) (ULONG_PTR)((LONG)0x80000060) )
#if(WINVER >= 0x0400)
#define HKEY_CURRENT_CONFIG                 (( HKEY ) (ULONG_PTR)((LONG)0x80000005) )
#define HKEY_DYN_DATA                       (( HKEY ) (ULONG_PTR)((LONG)0x80000006) )
#define HKEY_CURRENT_USER_LOCAL_SETTINGS    (( HKEY ) (ULONG_PTR)((LONG)0x80000007) )
```

### Set Registry Values

[RegSetValueExW](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regsetvalueexw):
```c
LSTATUS RegSetValueExW(
  [in]           HKEY       hKey,
  [in, optional] LPCWSTR    lpValueName,
                 DWORD      Reserved,
  [in]           DWORD      dwType,
  [in]           const BYTE *lpData,
  [in]           DWORD      cbData
);
```

To set values in the `HKEY_LOCAL_MACHINE` registry branch, we match the params in `RegSetValueExW` to the payload sent in stage 2.

### References:
- https://www.x86matthew.com/view_post?id=windows_seagate_lpe

